##DFS



##### vector建邻接表

```c++
struct edge {
    int to;
    int w;
};
vector<edge> G[100004];
```

构造：

```c++
G[b].push_back(edge{e, we});
```



思路框架：

```c++
/*两种dfs模式，一是在看该点能否访问，并访问下一层所有点（进dfs在看能否访问）
check写在最开始
二是访问该层中能访问的点，并进下一层（进dfs后找该层能进去的点）check写在for循环里面
第二种逻辑清楚点，dfs之后就将改变归位
*/
void dfs(x) {
    if (/*结束条件,最深层+1*/) {
       	//这里或许写在for中，最深层就不能继续访问
        }
    if (check(x)) {//这一步能不能走，多在有限制条件下的搜索（图等遍历就无）
        ans[x] += num;//走下这一步的改变，如对该点赋值；结点访问赋值
        for (/*所有下一层*/) {
            if(/*可以访问*/){
                bfs(x + 1);
            }
        }
        ans[x]-=num;//回溯回来，重置改变，
    }
}

void dfs(x){
    if(/*最深层+1*/){
    }
    for(/*所有下一层的节点*/){
        if(check(x)){
            //变化
            dfs(x+1);
            //重置
        }
    }
}

```